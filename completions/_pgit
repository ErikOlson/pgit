#compdef pgit pnp

# pgit zsh completion
# Install to an fpath directory or eval "$(pgit completions zsh)"

_pgit_complete() {
    local curcontext="$curcontext" state line
    typeset -A opt_args

    _arguments -C \
        '(-V --version)'{-V,--version}'[show version]' \
        '(-h --help)'{-h,--help}'[show help]' \
        '1: :->cmd' \
        '*: :->args'

    case $state in
        cmd)
            local -a pgit_cmds
            pgit_cmds=(
                'init:initialize pgit in current directory'
                'adopt:adopt pgit in an existing repo'
                'add-to-process:move file(s) from product to process'
                'pp:P&P multiplexer commands'
                'completions:print shell completion script'
                '-p:run git against the process repo'
            )
            _describe 'command' pgit_cmds

            # Also offer git commands
            local -a git_cmds
            git_cmds=(${(f)"$(git --list-cmds=main,others 2>/dev/null)"})
            (( ${#git_cmds} )) && compadd -- "${git_cmds[@]}"
            ;;
        args)
            case ${line[1]} in
                -p)
                    if (( CURRENT == 2 )); then
                        local -a git_cmds
                        git_cmds=(${(f)"$(git --list-cmds=main,others 2>/dev/null)"})
                        (( ${#git_cmds} )) && compadd -- "${git_cmds[@]}"
                    fi
                    ;;
                pp)
                    if (( CURRENT == 2 )); then
                        local -a pp_cmds
                        pp_cmds=(
                            'commit:commit across both repos'
                            'registry:manage pattern registry'
                            'remotes:show remotes for both repos'
                        )
                        _describe 'pp command' pp_cmds
                    elif (( CURRENT == 3 )) && [[ ${line[2]} == registry ]]; then
                        local -a reg_cmds
                        reg_cmds=(
                            'list:list all registry pattern sets'
                            'add:add a pattern to a registry set'
                            'remove:remove a pattern from registry'
                        )
                        _describe 'registry command' reg_cmds
                    fi
                    ;;
                adopt)
                    _arguments \
                        '(-y --yes)'{-y,--yes}'[skip confirmation prompt]'
                    ;;
                completions)
                    if (( CURRENT == 2 )); then
                        compadd -- bash zsh fish
                    fi
                    ;;
                add-to-process)
                    _files
                    ;;
            esac
            ;;
    esac
}

_pnp_complete() {
    local curcontext="$curcontext" state line
    typeset -A opt_args

    _arguments -C \
        '1: :->cmd' \
        '*: :->args'

    case $state in
        cmd)
            local -a pp_cmds
            pp_cmds=(
                'commit:commit across both repos'
                'registry:manage pattern registry'
                'remotes:show remotes for both repos'
            )
            _describe 'pp command' pp_cmds
            ;;
        args)
            if (( CURRENT == 2 )) && [[ ${line[1]} == registry ]]; then
                local -a reg_cmds
                reg_cmds=(
                    'list:list all registry pattern sets'
                    'add:add a pattern to a registry set'
                    'remove:remove a pattern from registry'
                )
                _describe 'registry command' reg_cmds
            fi
            ;;
    esac
}

# When loaded via fpath, $service is set by compinit from #compdef header.
# When sourced directly (eval approach), register with compdef.
if [[ -z "$service" ]]; then
    compdef _pgit_complete pgit
    compdef _pnp_complete pnp
else
    case $service in
        pgit) _pgit_complete "$@" ;;
        pnp)  _pnp_complete "$@" ;;
    esac
fi
