#!/bin/sh
# pgit — git multiplexer for process & product separation
# POSIX sh, no bashisms

set -e

PGIT_VERSION="0.1.0"

# --- Walk-up discovery ---
# Find .pgit/ directory by walking up from cwd.
# Sets PGIT_DIR (path to .pgit/) and PGIT_ROOT (project root).
pgit_find_root() {
    _dir="$PWD"
    while true; do
        if [ -d "$_dir/.pgit" ]; then
            PGIT_ROOT="$_dir"
            PGIT_DIR="$_dir/.pgit"
            return 0
        fi
        _parent="$(dirname "$_dir")"
        if [ "$_parent" = "$_dir" ]; then
            # Hit filesystem root
            return 1
        fi
        _dir="$_parent"
    done
}

# --- Helpers ---
pgit_die() {
    echo "pgit: $*" >&2
    exit 1
}

pgit_product_git() {
    GIT_DIR="$PGIT_ROOT/.git" GIT_WORK_TREE="$PGIT_ROOT" exec git "$@"
}

pgit_process_git() {
    GIT_DIR="$PGIT_DIR/layers/process/.git" GIT_WORK_TREE="$PGIT_ROOT" exec git "$@"
}

# Non-exec variants (for when the script needs to continue after git)
pgit_product_git_run() {
    GIT_DIR="$PGIT_ROOT/.git" GIT_WORK_TREE="$PGIT_ROOT" git "$@"
}

pgit_process_git_run() {
    GIT_DIR="$PGIT_DIR/layers/process/.git" GIT_WORK_TREE="$PGIT_ROOT" git "$@"
}

pgit_get_subdir() {
    case "$PWD" in
        "$PGIT_ROOT") ;;
        "$PGIT_ROOT"/*) echo "${PWD#"$PGIT_ROOT"/}" ;;
        *) pgit_die "current directory is outside project root" ;;
    esac
}

# --- Exclude sync ---
# Regenerate info/exclude files from config.json patterns.
# Called before add operations to handle config changes.
pgit_sync_excludes() {
    pgit_load_patterns

    _old_ifs="$IFS"
    IFS='
'

    # Collect directories that have negated children.
    # Git skips excluded directories entirely, so we must use dir/**
    # instead of dir/ when a negation exists for a file inside it.
    _negated_dirs=""
    for _pat in $PGIT_PROCESS_PATTERNS; do
        case "$_pat" in
            '!'*/*)
                _pos="${_pat#!}"
                _ndir="${_pos%/*}"
                _negated_dirs="$_negated_dirs|$_ndir"
                ;;
        esac
    done

    # --- Product repo info/exclude ---
    _exclude="$PGIT_ROOT/.git/info/exclude"
    if [ -f "$_exclude" ]; then
        _tmp=$(mktemp)
        sed '/^# pgit: process layer/,$d' "$_exclude" > "$_tmp"
        mv "$_tmp" "$_exclude"
    fi
    {
        echo "# pgit: process layer patterns (auto-generated, do not edit)"
        for _pat in $PGIT_PROCESS_PATTERNS; do
            [ -z "$_pat" ] && continue
            case "$_pat" in
                '!'*)
                    # Negation passes through directly
                    echo "$_pat"
                    ;;
                */)
                    # Directory pattern — use ** if negations exist inside
                    _dir="${_pat%/}"
                    case "$_negated_dirs" in
                        *"|$_dir"|*"|$_dir"*|"$_dir")
                            echo "$_dir/**"
                            ;;
                        *)
                            echo "$_pat"
                            ;;
                    esac
                    ;;
                *)
                    echo "$_pat"
                    ;;
            esac
        done
    } >> "$_exclude"

    # --- Process repo info/exclude ---
    _process_exclude="$PGIT_DIR/layers/process/.git/info/exclude"
    {
        echo "# pgit: product layer exclusions (auto-generated)"
        echo "*"
        for _pat in $PGIT_PROCESS_PATTERNS; do
            [ -z "$_pat" ] && continue
            # .pgit/ is infrastructure — neither repo should track it
            case "$_pat" in .pgit|.pgit/) continue ;; esac
            case "$_pat" in
                '!'*)
                    # Negation = "this goes to product" → re-exclude in process
                    _pos="${_pat#!}"
                    echo "$_pos"
                    ;;
                */)
                    _dir="${_pat%/}"
                    echo "!$_dir/"
                    echo "!$_dir/**"
                    ;;
                *)
                    echo "!$_pat"
                    ;;
            esac
        done
    } > "$_process_exclude"

    IFS="$_old_ifs"
}

# Check if the process repo has staged changes.
# Returns 0 if there ARE staged changes, 1 if there are none.
pgit_process_has_staged() {
    if GIT_DIR="$PGIT_DIR/layers/process/.git" git rev-parse HEAD >/dev/null 2>&1; then
        # Has commits — compare index to HEAD
        ! GIT_DIR="$PGIT_DIR/layers/process/.git" GIT_WORK_TREE="$PGIT_ROOT" \
            git diff-index --cached --quiet HEAD -- 2>/dev/null
    else
        # No commits yet — any cached files means staged changes
        _files=$(GIT_DIR="$PGIT_DIR/layers/process/.git" GIT_WORK_TREE="$PGIT_ROOT" \
            git ls-files --cached 2>/dev/null)
        [ -n "$_files" ]
    fi
}

# --- Pattern matching engine ---

pgit_load_patterns() {
    _config="$PGIT_DIR/config.json"
    PGIT_PROCESS_PATTERNS=""
    _in_patterns=0
    while IFS= read -r _line; do
        case "$_line" in
            *'"patterns"'*)
                _in_patterns=1
                continue
                ;;
        esac
        if [ "$_in_patterns" -eq 1 ]; then
            case "$_line" in
                *']'*)
                    _in_patterns=0
                    continue
                    ;;
                *)
                    _pat=$(echo "$_line" | sed -n 's/.*"\([^"]*\)".*/\1/p')
                    if [ -n "$_pat" ]; then
                        PGIT_PROCESS_PATTERNS="${PGIT_PROCESS_PATTERNS}${_pat}
"
                    fi
                    ;;
            esac
        fi
    done < "$_config"
}

# Classify a file path (relative to project root) as "process" or "product".
# Last matching pattern wins; negation (!) overrides.
pgit_classify_file() {
    _file="$1"
    _result="product"

    _old_ifs="$IFS"
    IFS='
'
    for _pat in $PGIT_PROCESS_PATTERNS; do
        case "$_pat" in
            '!'*)
                # Negation pattern
                _pos="${_pat#!}"
                if pgit_match_pattern "$_file" "$_pos"; then
                    _result="product"
                fi
                ;;
            *)
                if pgit_match_pattern "$_file" "$_pat"; then
                    _result="process"
                fi
                ;;
        esac
    done
    IFS="$_old_ifs"

    echo "$_result"
}

# Returns 0 if file matches pattern.
# Rules follow gitignore conventions:
#   pattern/  → directory (matches dir and contents)
#   */pattern → path-specific match
#   pattern   → basename match (no slash in pattern)
pgit_match_pattern() {
    _file="$1"
    _pattern="$2"

    case "$_pattern" in
        */)
            # Directory pattern — match the dir name or anything inside it
            _dir="${_pattern%/}"
            case "$_file" in
                "$_dir"/*|"$_dir") return 0 ;;
            esac
            ;;
        */*)
            # Path-specific pattern (contains /)
            case "$_file" in
                $_pattern) return 0 ;;
            esac
            ;;
        *)
            # Basename pattern — match against the filename component
            _base="${_file##*/}"
            case "$_base" in
                $_pattern) return 0 ;;
            esac
            ;;
    esac
    return 1
}

# --- Smart add ---

pgit_add() {
    # Sync excludes from config in case patterns changed
    pgit_sync_excludes

    # Check if any arg is a specific file (not a directory, flag, or ".")
    _needs_routing=false
    for _arg in "$@"; do
        case "$_arg" in
            -*|.) continue ;;
            *)
                if ! [ -d "$_arg" ]; then
                    _needs_routing=true
                    break
                fi
                ;;
        esac
    done

    if ! $_needs_routing; then
        # Broad add (., dirs, flags only) — pass to both repos, excludes handle routing
        pgit_product_git_run add "$@" || true
        pgit_process_git_run add "$@" || true
        return
    fi

    # Has specific files — classify and route
    pgit_load_patterns
    _subdir=$(pgit_get_subdir)

    # Collect flags
    _flags=""
    for _arg in "$@"; do
        case "$_arg" in
            -*) _flags="$_flags $_arg" ;;
        esac
    done

    _any_product=false
    _any_process=false

    for _arg in "$@"; do
        case "$_arg" in
            -*) continue ;;
            .)
                pgit_product_git_run add $_flags . || true
                pgit_process_git_run add $_flags . || true
                ;;
            *)
                if [ -d "$_arg" ]; then
                    pgit_product_git_run add $_flags "$_arg" || true
                    pgit_process_git_run add $_flags "$_arg" || true
                else
                    _relfile="$_arg"
                    if [ -n "$_subdir" ]; then
                        _relfile="$_subdir/$_arg"
                    fi
                    _layer=$(pgit_classify_file "$_relfile")
                    if [ "$_layer" = "process" ]; then
                        pgit_process_git_run add $_flags "$_arg"
                        _any_process=true
                    else
                        pgit_product_git_run add $_flags "$_arg"
                        _any_product=true
                    fi
                fi
                ;;
        esac
    done

    # Report when files were split across layers
    if $_any_product && $_any_process; then
        echo "pgit: files staged in both product and process layers" >&2
    fi
}

# --- Smart commit ---

pgit_commit() {
    _auto=$(pgit_config_get "pp.auto-commit")

    if [ "$_auto" = "true" ]; then
        pgit_product_git_run commit "$@" || true
        pgit_process_git_run commit "$@" || true
        return
    fi

    # Normal commit: product repo, then nudge about process
    _exit=0
    pgit_product_git_run commit "$@" || _exit=$?

    if pgit_process_has_staged; then
        echo "pgit: process layer has staged changes. Run 'pgit -p commit' or 'pnp commit'." >&2
    fi

    exit $_exit
}

# --- pgit pp commit ---

pgit_pp_commit() {
    # Extract -m message for sync default
    _msg=""
    _skip_next=false
    for _arg in "$@"; do
        if $_skip_next; then
            _msg="$_arg"
            _skip_next=false
            continue
        fi
        case "$_arg" in
            -m) _skip_next=true ;;
            -m*) _msg="${_arg#-m}" ;;
        esac
    done

    # Commit product
    _exit=0
    pgit_product_git_run commit "$@" || _exit=$?

    # Check if process has anything to commit
    if ! pgit_process_has_staged; then
        exit $_exit
    fi

    # Commit process with sync message
    if [ -n "$_msg" ]; then
        _process_msg="sync: $_msg"
    else
        _process_msg="sync: process update"
    fi
    pgit_process_git_run commit -m "$_process_msg" || true

    exit $_exit
}

# --- Config ---

pgit_config_get() {
    _key="$1"
    _config_file="$PGIT_DIR/config"
    if [ -f "$_config_file" ]; then
        _val=$(grep "^$_key=" "$_config_file" 2>/dev/null | head -1) || true
        echo "${_val#"$_key"=}"
    fi
}

pgit_config_set() {
    _key="$1"
    _value="$2"
    _config_file="$PGIT_DIR/config"

    if [ ! -f "$_config_file" ]; then
        echo "$_key=$_value" > "$_config_file"
    elif grep -q "^$_key=" "$_config_file" 2>/dev/null; then
        _tmp=$(mktemp)
        sed "s/^$_key=.*/$_key=$_value/" "$_config_file" > "$_tmp"
        mv "$_tmp" "$_config_file"
    else
        echo "$_key=$_value" >> "$_config_file"
    fi
}

pgit_config_cmd() {
    if [ $# -eq 0 ]; then
        if [ -f "$PGIT_DIR/config" ]; then
            cat "$PGIT_DIR/config"
        fi
        return
    fi
    if [ $# -eq 1 ]; then
        pgit_config_get "$1"
        return
    fi
    pgit_config_set "$1" "$2"
}

# --- pgit init ---
pgit_init() {
    # Must be run from a directory with .git/
    if [ ! -d ".git" ]; then
        pgit_die "not a git repository. Run 'git init' first."
    fi

    if [ -d ".pgit" ]; then
        pgit_die "already initialized (.pgit/ exists)."
    fi

    _root="$PWD"

    # Create directory structure
    mkdir -p ".pgit/layers/process"

    # Write default config
    cat > ".pgit/config.json" << 'CONF'
{
  "version": 1,
  "default_layer": "product",
  "layers": {
    "product": {
      "git_dir": ".git"
    },
    "process": {
      "git_dir": ".pgit/layers/process/.git",
      "patterns": [
        "CLAUDE.md",
        ".claude/",
        "AGENTS.md",
        "PLAN.md",
        "TASKS.md",
        "*.agent-log",
        ".pgit/"
      ]
    }
  }
}
CONF

    # Initialize process repo
    git init --bare ".pgit/layers/process/.git" >/dev/null 2>&1
    git --git-dir=".pgit/layers/process/.git" config core.bare false
    git --git-dir=".pgit/layers/process/.git" config core.worktree "$_root"

    # Generate info/exclude for product repo
    _exclude=".git/info/exclude"
    mkdir -p ".git/info"

    # Preserve existing excludes, append pgit section
    if [ -f "$_exclude" ]; then
        # Check if we already have a pgit section (shouldn't happen, but be safe)
        if grep -q "# pgit: process layer" "$_exclude" 2>/dev/null; then
            pgit_die "info/exclude already has pgit entries — this shouldn't happen."
        fi
    fi

    {
        echo ""
        echo "# pgit: process layer patterns (auto-generated, do not edit)"
        echo "CLAUDE.md"
        echo ".claude/"
        echo "AGENTS.md"
        echo "PLAN.md"
        echo "TASKS.md"
        echo "*.agent-log"
        echo ".pgit/"
    } >> "$_exclude"

    # Also exclude process patterns from the process repo's view of product files
    _process_exclude=".pgit/layers/process/.git/info/exclude"
    mkdir -p ".pgit/layers/process/.git/info"
    {
        echo "# pgit: product layer exclusions (everything NOT in process patterns)"
        echo "*"
        echo "!CLAUDE.md"
        echo "!.claude/"
        echo "!.claude/**"
        echo "!AGENTS.md"
        echo "!PLAN.md"
        echo "!TASKS.md"
        echo "!*.agent-log"
    } > "$_process_exclude"

    echo "pgit: initialized process layer in .pgit/"
    echo "  process patterns: CLAUDE.md .claude/ AGENTS.md PLAN.md TASKS.md *.agent-log"
    echo "  product repo info/exclude updated"
    echo ""
    echo "Use 'pgit' for product, 'pgit -p' for process."
}

# --- pgit pp ---
pgit_pp() {
    if [ $# -eq 0 ]; then
        pgit_pp_overview
        return
    fi

    case "$1" in
        commit)
            shift
            pgit_pp_commit "$@"
            ;;
        *)
            pgit_die "unknown pp command: $1"
            ;;
    esac
}

pgit_pp_overview() {
    if ! pgit_find_root; then
        pgit_die "not a pgit directory (no .pgit/ found)."
    fi

    _product_branch=$(git --git-dir="$PGIT_ROOT/.git" --work-tree="$PGIT_ROOT" rev-parse --abbrev-ref HEAD 2>/dev/null || echo "(no commits)")
    _process_branch=$(git --git-dir="$PGIT_DIR/layers/process/.git" --work-tree="$PGIT_ROOT" rev-parse --abbrev-ref HEAD 2>/dev/null || echo "(no commits)")

    # Check dirty status
    if git --git-dir="$PGIT_ROOT/.git" --work-tree="$PGIT_ROOT" diff --quiet 2>/dev/null && \
       git --git-dir="$PGIT_ROOT/.git" --work-tree="$PGIT_ROOT" diff --cached --quiet 2>/dev/null; then
        _product_status="clean"
    else
        _product_status="dirty"
    fi

    if git --git-dir="$PGIT_DIR/layers/process/.git" --work-tree="$PGIT_ROOT" diff --quiet 2>/dev/null && \
       git --git-dir="$PGIT_DIR/layers/process/.git" --work-tree="$PGIT_ROOT" diff --cached --quiet 2>/dev/null; then
        _process_status="clean"
    else
        _process_status="dirty"
    fi

    # Last commit
    _product_commit=$(git --git-dir="$PGIT_ROOT/.git" log --oneline -1 2>/dev/null || echo "(no commits)")
    _process_commit=$(git --git-dir="$PGIT_DIR/layers/process/.git" log --oneline -1 2>/dev/null || echo "(no commits)")

    echo "product  [$_product_branch] $_product_status"
    echo "  $_product_commit"
    echo "process  [$_process_branch] $_process_status"
    echo "  $_process_commit"
}

# --- Main dispatch ---

# Handle --help and --version before anything else
case "${1:-}" in
    --version|-V)
        echo "pgit $PGIT_VERSION"
        exit 0
        ;;
    --help|-h)
        echo "usage: pgit [--version] [-p] <git-command> [<args>]"
        echo "       pgit init"
        echo "       pgit pp <command>"
        echo ""
        echo "Git multiplexer for process & product separation."
        echo ""
        echo "  pgit <cmd>      Run git against the product repo"
        echo "  pgit -p <cmd>   Run git against the process repo"
        echo "  pgit pp <cmd>   P&P multiplexer commands"
        echo "  pgit init       Initialize pgit in current directory"
        exit 0
        ;;
esac

# Special case: pgit init doesn't need .pgit/ to exist
if [ "${1:-}" = "init" ]; then
    shift
    pgit_init "$@"
    exit 0
fi

# pgit-specific commands require .pgit/
case "${1:-}" in
    -p|pp)
        if ! pgit_find_root; then
            pgit_die "not a pgit directory (no .pgit/ found)."
        fi
        case "$1" in
            -p)
                shift
                if [ $# -eq 0 ]; then
                    pgit_process_git status
                else
                    pgit_process_git "$@"
                fi
                ;;
            pp)
                shift
                pgit_pp "$@"
                ;;
        esac
        ;;
    *)
        if pgit_find_root; then
            case "$1" in
                add)
                    shift
                    pgit_add "$@"
                    ;;
                commit)
                    shift
                    pgit_commit "$@"
                    ;;
                config)
                    # pp.* keys → pgit config; everything else → git config
                    case "${2:-}" in
                        pp.*)
                            shift
                            pgit_config_cmd "$@"
                            ;;
                        *)
                            pgit_product_git "$@"
                            ;;
                    esac
                    ;;
                *)
                    pgit_product_git "$@"
                    ;;
            esac
        else
            exec git "$@"
        fi
        ;;
esac
