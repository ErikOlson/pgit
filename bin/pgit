#!/bin/sh
# pgit — git multiplexer for process & product separation
# POSIX sh, no bashisms

set -e

PGIT_VERSION="0.2.0"
PGIT_REGISTRY_DIR="${XDG_CONFIG_HOME:-$HOME/.config}/pgit/patterns"

# --- Walk-up discovery ---
# Find .pgit/ directory by walking up from cwd.
# Sets PGIT_DIR (path to .pgit/) and PGIT_ROOT (project root).
pgit_find_root() {
    _dir="$PWD"
    while true; do
        if [ -d "$_dir/.pgit" ]; then
            PGIT_ROOT="$_dir"
            PGIT_DIR="$_dir/.pgit"
            return 0
        fi
        _parent="$(dirname "$_dir")"
        if [ "$_parent" = "$_dir" ]; then
            # Hit filesystem root
            return 1
        fi
        _dir="$_parent"
    done
}

# --- Helpers ---
pgit_die() {
    echo "pgit: $*" >&2
    exit 1
}

pgit_product_git() {
    GIT_DIR="$PGIT_ROOT/.git" GIT_WORK_TREE="$PGIT_ROOT" exec git "$@"
}

pgit_process_git() {
    GIT_DIR="$PGIT_DIR/layers/process/.git" GIT_WORK_TREE="$PGIT_ROOT" exec git "$@"
}

# Non-exec variants (for when the script needs to continue after git)
pgit_product_git_run() {
    GIT_DIR="$PGIT_ROOT/.git" GIT_WORK_TREE="$PGIT_ROOT" git "$@"
}

pgit_process_git_run() {
    GIT_DIR="$PGIT_DIR/layers/process/.git" GIT_WORK_TREE="$PGIT_ROOT" git "$@"
}

pgit_get_subdir() {
    case "$PWD" in
        "$PGIT_ROOT") ;;
        "$PGIT_ROOT"/*) echo "${PWD#"$PGIT_ROOT"/}" ;;
        *) pgit_die "current directory is outside project root" ;;
    esac
}

# --- Exclude sync ---
# Regenerate info/exclude files from config.json patterns.
# Called before add operations to handle config changes.
pgit_sync_excludes() {
    pgit_load_patterns

    _old_ifs="$IFS"
    IFS='
'

    # Collect directories that have negated children.
    # Git skips excluded directories entirely, so we must use dir/**
    # instead of dir/ when a negation exists for a file inside it.
    _negated_dirs=""
    for _pat in $PGIT_PROCESS_PATTERNS; do
        case "$_pat" in
            '!'*/*)
                _pos="${_pat#!}"
                _ndir="${_pos%/*}"
                _negated_dirs="$_negated_dirs|$_ndir"
                ;;
        esac
    done

    # --- Product repo info/exclude ---
    _exclude="$PGIT_ROOT/.git/info/exclude"
    if [ -f "$_exclude" ]; then
        _tmp=$(mktemp)
        sed '/^# pgit: process layer/,$d' "$_exclude" > "$_tmp"
        mv "$_tmp" "$_exclude"
    fi
    {
        echo "# pgit: process layer patterns (auto-generated, do not edit)"
        for _pat in $PGIT_PROCESS_PATTERNS; do
            [ -z "$_pat" ] && continue
            case "$_pat" in
                '!'*)
                    # Negation passes through directly
                    echo "$_pat"
                    ;;
                */)
                    # Directory pattern — use ** if negations exist inside
                    _dir="${_pat%/}"
                    case "$_negated_dirs" in
                        *"|$_dir"|*"|$_dir"*|"$_dir")
                            echo "$_dir/**"
                            ;;
                        *)
                            echo "$_pat"
                            ;;
                    esac
                    ;;
                *)
                    echo "$_pat"
                    ;;
            esac
        done
    } >> "$_exclude"

    # --- Process repo info/exclude ---
    _process_exclude="$PGIT_DIR/layers/process/.git/info/exclude"
    {
        echo "# pgit: product layer exclusions (auto-generated)"
        echo "*"
        for _pat in $PGIT_PROCESS_PATTERNS; do
            [ -z "$_pat" ] && continue
            # .pgit/ is infrastructure — neither repo should track it
            case "$_pat" in .pgit|.pgit/) continue ;; esac
            case "$_pat" in
                '!'*)
                    # Negation = "this goes to product" → re-exclude in process
                    _pos="${_pat#!}"
                    echo "$_pos"
                    ;;
                */)
                    _dir="${_pat%/}"
                    echo "!$_dir/"
                    echo "!$_dir/**"
                    ;;
                *)
                    echo "!$_pat"
                    ;;
            esac
        done
    } > "$_process_exclude"

    IFS="$_old_ifs"
}

# Check if the process repo has staged changes.
# Returns 0 if there ARE staged changes, 1 if there are none.
pgit_process_has_staged() {
    if GIT_DIR="$PGIT_DIR/layers/process/.git" git rev-parse HEAD >/dev/null 2>&1; then
        # Has commits — compare index to HEAD
        ! GIT_DIR="$PGIT_DIR/layers/process/.git" GIT_WORK_TREE="$PGIT_ROOT" \
            git diff-index --cached --quiet HEAD -- 2>/dev/null
    else
        # No commits yet — any cached files means staged changes
        _files=$(GIT_DIR="$PGIT_DIR/layers/process/.git" GIT_WORK_TREE="$PGIT_ROOT" \
            git ls-files --cached 2>/dev/null)
        [ -n "$_files" ]
    fi
}

# --- Pattern matching engine ---

pgit_load_patterns() {
    _config="$PGIT_DIR/config.json"
    PGIT_PROCESS_PATTERNS=""
    _in_patterns=0
    while IFS= read -r _line; do
        case "$_line" in
            *'"patterns"'*)
                _in_patterns=1
                continue
                ;;
        esac
        if [ "$_in_patterns" -eq 1 ]; then
            case "$_line" in
                *']'*)
                    _in_patterns=0
                    continue
                    ;;
                *)
                    _pat=$(echo "$_line" | sed -n 's/.*"\([^"]*\)".*/\1/p')
                    if [ -n "$_pat" ]; then
                        PGIT_PROCESS_PATTERNS="${PGIT_PROCESS_PATTERNS}${_pat}
"
                    fi
                    ;;
            esac
        fi
    done < "$_config"
}

# Classify a file path (relative to project root) as "process" or "product".
# Last matching pattern wins; negation (!) overrides.
pgit_classify_file() {
    _file="$1"
    _result="product"

    _old_ifs="$IFS"
    IFS='
'
    for _pat in $PGIT_PROCESS_PATTERNS; do
        case "$_pat" in
            '!'*)
                # Negation pattern
                _pos="${_pat#!}"
                if pgit_match_pattern "$_file" "$_pos"; then
                    _result="product"
                fi
                ;;
            *)
                if pgit_match_pattern "$_file" "$_pat"; then
                    _result="process"
                fi
                ;;
        esac
    done
    IFS="$_old_ifs"

    echo "$_result"
}

# Returns 0 if file matches pattern.
# Rules follow gitignore conventions:
#   pattern/  → directory (matches dir and contents)
#   */pattern → path-specific match
#   pattern   → basename match (no slash in pattern)
pgit_match_pattern() {
    _file="$1"
    _pattern="$2"

    case "$_pattern" in
        */)
            # Directory pattern — match the dir name or anything inside it
            _dir="${_pattern%/}"
            case "$_file" in
                "$_dir"/*|"$_dir") return 0 ;;
            esac
            ;;
        */*)
            # Path-specific pattern (contains /)
            case "$_file" in
                $_pattern) return 0 ;;
            esac
            ;;
        *)
            # Basename pattern — match against the filename component
            _base="${_file##*/}"
            case "$_base" in
                $_pattern) return 0 ;;
            esac
            ;;
    esac
    return 1
}

# --- Smart add ---

pgit_add() {
    # Sync excludes from config in case patterns changed
    pgit_sync_excludes

    # Check if any arg is a specific file (not a directory, flag, or ".")
    _needs_routing=false
    for _arg in "$@"; do
        case "$_arg" in
            -*|.) continue ;;
            *)
                if ! [ -d "$_arg" ]; then
                    _needs_routing=true
                    break
                fi
                ;;
        esac
    done

    if ! $_needs_routing; then
        # Broad add (., dirs, flags only) — pass to both repos, excludes handle routing
        pgit_product_git_run add "$@" || true
        pgit_process_git_run add "$@" || true
        return
    fi

    # Has specific files — classify and route
    pgit_load_patterns
    _subdir=$(pgit_get_subdir)

    # Collect flags
    _flags=""
    for _arg in "$@"; do
        case "$_arg" in
            -*) _flags="$_flags $_arg" ;;
        esac
    done

    _any_product=false
    _any_process=false

    for _arg in "$@"; do
        case "$_arg" in
            -*) continue ;;
            .)
                pgit_product_git_run add $_flags . || true
                pgit_process_git_run add $_flags . || true
                ;;
            *)
                if [ -d "$_arg" ]; then
                    pgit_product_git_run add $_flags "$_arg" || true
                    pgit_process_git_run add $_flags "$_arg" || true
                else
                    _relfile="$_arg"
                    if [ -n "$_subdir" ]; then
                        _relfile="$_subdir/$_arg"
                    fi
                    _layer=$(pgit_classify_file "$_relfile")
                    if [ "$_layer" = "process" ]; then
                        pgit_process_git_run add $_flags "$_arg"
                        _any_process=true
                    else
                        pgit_product_git_run add $_flags "$_arg"
                        _any_product=true
                    fi
                fi
                ;;
        esac
    done

    # Report when files were split across layers
    if $_any_product && $_any_process; then
        echo "pgit: files staged in both product and process layers" >&2
    fi
}

# --- Smart commit ---

pgit_commit() {
    _auto=$(pgit_config_get "pp.auto-commit")

    if [ "$_auto" = "true" ]; then
        pgit_product_git_run commit "$@" || true
        pgit_process_git_run commit "$@" || true
        return
    fi

    # Normal commit: product repo, then nudge about process
    _exit=0
    pgit_product_git_run commit "$@" || _exit=$?

    if pgit_process_has_staged; then
        echo "pgit: process layer has staged changes. Run 'pgit -p commit' or 'pnp commit'." >&2
    fi

    exit $_exit
}

# --- pgit pp commit ---

pgit_pp_commit() {
    # Extract -m message for sync default
    _msg=""
    _skip_next=false
    for _arg in "$@"; do
        if $_skip_next; then
            _msg="$_arg"
            _skip_next=false
            continue
        fi
        case "$_arg" in
            -m) _skip_next=true ;;
            -m*) _msg="${_arg#-m}" ;;
        esac
    done

    # Commit product (may fail if nothing to commit — that's OK)
    _product_exit=0
    pgit_product_git_run commit "$@" || _product_exit=$?

    # Check if process has anything to commit
    if ! pgit_process_has_staged; then
        exit $_product_exit
    fi

    # Commit process with sync message
    if [ -n "$_msg" ]; then
        _process_msg="sync: $_msg"
    else
        _process_msg="sync: process update"
    fi
    pgit_process_git_run commit -m "$_process_msg"

    # Success if either repo committed
    exit 0
}

# --- pgit pp registry ---

pgit_pp_registry() {
    if [ $# -eq 0 ]; then
        pgit_registry_list
        return
    fi

    case "$1" in
        list)
            pgit_registry_list
            ;;
        add)
            shift
            [ $# -eq 0 ] && pgit_die "usage: pnp registry add <pattern> [set-name]"
            pgit_registry_add "$@"
            ;;
        remove)
            shift
            [ $# -eq 0 ] && pgit_die "usage: pnp registry remove <pattern>"
            pgit_registry_remove "$1"
            ;;
        *)
            pgit_die "unknown registry command: $1. Use list, add, or remove."
            ;;
    esac
}

# --- Config ---

pgit_config_get() {
    _key="$1"
    _config_file="$PGIT_DIR/config"
    if [ -f "$_config_file" ]; then
        _val=$(grep "^$_key=" "$_config_file" 2>/dev/null | head -1) || true
        echo "${_val#"$_key"=}"
    fi
}

pgit_config_set() {
    _key="$1"
    _value="$2"
    _config_file="$PGIT_DIR/config"

    if [ ! -f "$_config_file" ]; then
        echo "$_key=$_value" > "$_config_file"
    elif grep -q "^$_key=" "$_config_file" 2>/dev/null; then
        _tmp=$(mktemp)
        sed "s/^$_key=.*/$_key=$_value/" "$_config_file" > "$_tmp"
        mv "$_tmp" "$_config_file"
    else
        echo "$_key=$_value" >> "$_config_file"
    fi
}

pgit_config_cmd() {
    if [ $# -eq 0 ]; then
        if [ -f "$PGIT_DIR/config" ]; then
            cat "$PGIT_DIR/config"
        fi
        return
    fi
    if [ $# -eq 1 ]; then
        pgit_config_get "$1"
        return
    fi
    pgit_config_set "$1" "$2"
}

# --- Registry ---

# Ensure registry dir exists and install built-in patterns if missing.
pgit_ensure_registry() {
    mkdir -p "$PGIT_REGISTRY_DIR"
    if [ ! -f "$PGIT_REGISTRY_DIR/claude-code.json" ]; then
        cat > "$PGIT_REGISTRY_DIR/claude-code.json" << 'BUILTIN'
{
  "name": "claude-code",
  "description": "Claude Code process files",
  "patterns": [
    "CLAUDE.md",
    ".claude/",
    "AGENTS.md",
    "PLAN.md",
    "TASKS.md"
  ]
}
BUILTIN
    fi
    if [ ! -f "$PGIT_REGISTRY_DIR/agent-logs.json" ]; then
        cat > "$PGIT_REGISTRY_DIR/agent-logs.json" << 'BUILTIN'
{
  "name": "agent-logs",
  "description": "Agent log files",
  "patterns": [
    "*.agent-log"
  ]
}
BUILTIN
    fi
}

# Collect all patterns from registry into a newline-separated list.
# Sets PGIT_REGISTRY_PATTERNS.
pgit_load_registry_patterns() {
    pgit_ensure_registry
    PGIT_REGISTRY_PATTERNS=""
    for _f in "$PGIT_REGISTRY_DIR"/*.json; do
        [ -f "$_f" ] || continue
        _pats=$(pgit_read_registry_file "$_f")
        _old_ifs="$IFS"
        IFS='
'
        for _p in $_pats; do
            [ -z "$_p" ] && continue
            # Deduplicate
            case "$PGIT_REGISTRY_PATTERNS" in
                *"$_p"*) ;;
                *) PGIT_REGISTRY_PATTERNS="${PGIT_REGISTRY_PATTERNS}${_p}
" ;;
            esac
        done
        IFS="$_old_ifs"
    done
}

# List all registry pattern sets.
pgit_registry_list() {
    pgit_ensure_registry
    for _f in "$PGIT_REGISTRY_DIR"/*.json; do
        [ -f "$_f" ] || continue
        _name=$(sed -n 's/.*"name"[[:space:]]*:[[:space:]]*"\([^"]*\)".*/\1/p' "$_f")
        _desc=$(sed -n 's/.*"description"[[:space:]]*:[[:space:]]*"\([^"]*\)".*/\1/p' "$_f")
        _pats=$(pgit_read_registry_file "$_f")
        _display=""
        _old_ifs="$IFS"
        IFS='
'
        for _p in $_pats; do
            [ -n "$_p" ] && _display="$_display $_p"
        done
        IFS="$_old_ifs"
        echo "$_name — $_desc"
        echo "  patterns:$_display"
    done
}

# Read name, description, and patterns from a registry JSON file.
# Sets _rname, _rdesc, and outputs patterns to stdout (one per line).
pgit_read_registry_file() {
    _rf="$1"
    _rname=$(sed -n 's/.*"name"[[:space:]]*:[[:space:]]*"\([^"]*\)".*/\1/p' "$_rf")
    _rdesc=$(sed -n 's/.*"description"[[:space:]]*:[[:space:]]*"\([^"]*\)".*/\1/p' "$_rf")
    _in_pat=0
    while IFS= read -r _line; do
        case "$_line" in
            *'"patterns"'*) _in_pat=1; continue ;;
        esac
        if [ "$_in_pat" -eq 1 ]; then
            case "$_line" in
                *']'*) _in_pat=0; continue ;;
                *)
                    _p=$(echo "$_line" | sed -n 's/.*"\([^"]*\)".*/\1/p')
                    [ -n "$_p" ] && echo "$_p"
                    ;;
            esac
        fi
    done < "$_rf"
}

# Write a registry JSON file from name, description, and patterns (one per line on stdin).
pgit_write_registry_file() {
    _wf="$1"
    _wname="$2"
    _wdesc="$3"
    _wpats=""
    _wfirst=true
    while IFS= read -r _wp; do
        [ -z "$_wp" ] && continue
        if $_wfirst; then
            _wpats="    \"$_wp\""
            _wfirst=false
        else
            _wpats="$_wpats,
    \"$_wp\""
        fi
    done
    cat > "$_wf" << EOF
{
  "name": "$_wname",
  "description": "$_wdesc",
  "patterns": [
$_wpats
  ]
}
EOF
}

# Add a pattern to a registry set.
# Usage: pgit_registry_add <pattern> [set-name]
pgit_registry_add() {
    _pattern="$1"
    _set="${2:-custom}"
    _file="$PGIT_REGISTRY_DIR/$_set.json"

    pgit_ensure_registry

    if [ -f "$_file" ]; then
        if grep -q "\"$_pattern\"" "$_file" 2>/dev/null; then
            echo "pgit: pattern '$_pattern' already in set '$_set'" >&2
            return 0
        fi
        _existing=$(pgit_read_registry_file "$_file")
        _name=$(sed -n 's/.*"name"[[:space:]]*:[[:space:]]*"\([^"]*\)".*/\1/p' "$_file")
        _desc=$(sed -n 's/.*"description"[[:space:]]*:[[:space:]]*"\([^"]*\)".*/\1/p' "$_file")
        { echo "$_existing"; echo "$_pattern"; } | pgit_write_registry_file "$_file" "$_name" "$_desc"
    else
        echo "$_pattern" | pgit_write_registry_file "$_file" "$_set" "Custom patterns"
    fi
    echo "pgit: added '$_pattern' to registry set '$_set'"
}

# Remove a pattern from registry.
pgit_registry_remove() {
    _pattern="$1"

    pgit_ensure_registry

    _found=false
    for _f in "$PGIT_REGISTRY_DIR"/*.json; do
        [ -f "$_f" ] || continue
        if grep -q "\"$_pattern\"" "$_f" 2>/dev/null; then
            _existing=$(pgit_read_registry_file "$_f")
            _name=$(sed -n 's/.*"name"[[:space:]]*:[[:space:]]*"\([^"]*\)".*/\1/p' "$_f")
            _desc=$(sed -n 's/.*"description"[[:space:]]*:[[:space:]]*"\([^"]*\)".*/\1/p' "$_f")
            echo "$_existing" | grep -v "^${_pattern}$" | \
                pgit_write_registry_file "$_f" "$_name" "$_desc"
            echo "pgit: removed '$_pattern' from registry set '$_name'"
            _found=true
        fi
    done

    if ! $_found; then
        pgit_die "pattern '$_pattern' not found in registry"
    fi
}

# --- pgit init ---
pgit_init() {
    # Must be run from a directory with .git/
    if [ ! -d ".git" ]; then
        pgit_die "not a git repository. Run 'git init' first."
    fi

    if [ -d ".pgit" ]; then
        pgit_die "already initialized (.pgit/ exists)."
    fi

    _root="$PWD"

    # Load patterns from registry
    pgit_load_registry_patterns

    # Build patterns list: registry patterns + .pgit/ (always included)
    _patterns="$PGIT_REGISTRY_PATTERNS"
    # Ensure .pgit/ is always present
    case "$_patterns" in
        *".pgit/"*) ;;
        *) _patterns="${_patterns}.pgit/
" ;;
    esac

    # Create directory structure
    mkdir -p ".pgit/layers/process"

    # Write config.json with registry-sourced patterns
    _old_ifs="$IFS"
    IFS='
'
    _json_patterns=""
    _display_patterns=""
    for _pat in $_patterns; do
        [ -z "$_pat" ] && continue
        if [ -n "$_json_patterns" ]; then
            _json_patterns="$_json_patterns,
        \"$_pat\""
        else
            _json_patterns="\"$_pat\""
        fi
        _display_patterns="$_display_patterns $_pat"
    done
    IFS="$_old_ifs"

    cat > ".pgit/config.json" << EOF
{
  "version": 1,
  "default_layer": "product",
  "layers": {
    "product": {
      "git_dir": ".git"
    },
    "process": {
      "git_dir": ".pgit/layers/process/.git",
      "patterns": [
        $_json_patterns
      ]
    }
  }
}
EOF

    # Initialize process repo
    git init --bare ".pgit/layers/process/.git" >/dev/null 2>&1
    git --git-dir=".pgit/layers/process/.git" config core.bare false
    git --git-dir=".pgit/layers/process/.git" config core.worktree "$_root"

    # Set PGIT_DIR/PGIT_ROOT so pgit_sync_excludes works
    PGIT_DIR="$_root/.pgit"
    PGIT_ROOT="$_root"

    # Generate info/exclude for both repos
    _exclude=".git/info/exclude"
    mkdir -p ".git/info"
    mkdir -p ".pgit/layers/process/.git/info"

    # Preserve existing product excludes, append pgit section
    if [ -f "$_exclude" ]; then
        if grep -q "# pgit: process layer" "$_exclude" 2>/dev/null; then
            pgit_die "info/exclude already has pgit entries — this shouldn't happen."
        fi
    fi

    pgit_sync_excludes

    echo "pgit: initialized process layer in .pgit/"
    echo "  process patterns:$_display_patterns"
    echo "  product repo info/exclude updated"
    echo ""
    echo "Use 'pgit' for product, 'pgit -p' for process."
}

# --- pgit pp ---
pgit_pp() {
    if [ $# -eq 0 ]; then
        pgit_pp_overview
        return
    fi

    case "$1" in
        commit)
            shift
            pgit_pp_commit "$@"
            ;;
        registry)
            shift
            pgit_pp_registry "$@"
            ;;
        *)
            pgit_die "unknown pp command: $1"
            ;;
    esac
}

pgit_pp_overview() {
    if ! pgit_find_root; then
        pgit_die "not a pgit directory (no .pgit/ found)."
    fi

    _product_branch=$(git --git-dir="$PGIT_ROOT/.git" --work-tree="$PGIT_ROOT" rev-parse --abbrev-ref HEAD 2>/dev/null || echo "(no commits)")
    _process_branch=$(git --git-dir="$PGIT_DIR/layers/process/.git" --work-tree="$PGIT_ROOT" rev-parse --abbrev-ref HEAD 2>/dev/null || echo "(no commits)")

    # Check dirty status
    if git --git-dir="$PGIT_ROOT/.git" --work-tree="$PGIT_ROOT" diff --quiet 2>/dev/null && \
       git --git-dir="$PGIT_ROOT/.git" --work-tree="$PGIT_ROOT" diff --cached --quiet 2>/dev/null; then
        _product_status="clean"
    else
        _product_status="dirty"
    fi

    if git --git-dir="$PGIT_DIR/layers/process/.git" --work-tree="$PGIT_ROOT" diff --quiet 2>/dev/null && \
       git --git-dir="$PGIT_DIR/layers/process/.git" --work-tree="$PGIT_ROOT" diff --cached --quiet 2>/dev/null; then
        _process_status="clean"
    else
        _process_status="dirty"
    fi

    # Last commit
    _product_commit=$(git --git-dir="$PGIT_ROOT/.git" log --oneline -1 2>/dev/null || echo "(no commits)")
    _process_commit=$(git --git-dir="$PGIT_DIR/layers/process/.git" log --oneline -1 2>/dev/null || echo "(no commits)")

    echo "product  [$_product_branch] $_product_status"
    echo "  $_product_commit"
    echo "process  [$_process_branch] $_process_status"
    echo "  $_process_commit"
}

# --- Main dispatch ---

# Handle --help and --version before anything else
case "${1:-}" in
    --version|-V)
        echo "pgit $PGIT_VERSION"
        exit 0
        ;;
    --help|-h)
        echo "usage: pgit [--version] [-p] <git-command> [<args>]"
        echo "       pgit init"
        echo "       pgit pp <command>"
        echo ""
        echo "Git multiplexer for process & product separation."
        echo ""
        echo "  pgit <cmd>      Run git against the product repo"
        echo "  pgit -p <cmd>   Run git against the process repo"
        echo "  pgit pp <cmd>   P&P multiplexer commands"
        echo "  pgit init       Initialize pgit in current directory"
        exit 0
        ;;
esac

# Special case: pgit init doesn't need .pgit/ to exist
if [ "${1:-}" = "init" ]; then
    shift
    pgit_init "$@"
    exit 0
fi

# pp registry works without .pgit/
if [ "${1:-}" = "pp" ] && [ "${2:-}" = "registry" ]; then
    shift 2
    pgit_pp_registry "$@"
    exit 0
fi

# pgit-specific commands require .pgit/
case "${1:-}" in
    -p|pp)
        if ! pgit_find_root; then
            pgit_die "not a pgit directory (no .pgit/ found)."
        fi
        case "$1" in
            -p)
                shift
                if [ $# -eq 0 ]; then
                    pgit_process_git status
                else
                    pgit_process_git "$@"
                fi
                ;;
            pp)
                shift
                pgit_pp "$@"
                ;;
        esac
        ;;
    *)
        if pgit_find_root; then
            case "$1" in
                add)
                    shift
                    pgit_add "$@"
                    ;;
                commit)
                    shift
                    pgit_commit "$@"
                    ;;
                config)
                    # pp.* keys → pgit config; everything else → git config
                    case "${2:-}" in
                        pp.*)
                            shift
                            pgit_config_cmd "$@"
                            ;;
                        *)
                            pgit_product_git "$@"
                            ;;
                    esac
                    ;;
                *)
                    pgit_product_git "$@"
                    ;;
            esac
        else
            exec git "$@"
        fi
        ;;
esac
